// nokia snake.cpp : Defines the entry point for the console application.
//UNDER CONSTRUCTION

#include "stdafx.h"
#include<iostream>
#include<time.h>
using namespace std;

//body=1 , represented by O
//food=-2 , represented by $
//wall=-1  , represented by # 
//rest=0  , represented by ' '
const int width=70;
const int height=20;
int foodpos;
const int size=height*width;
int MAP[size];
void endgame();
void updatesnake();
void generatefood();
void initialise();
void updatemap();
void getdirection();
bool checkfood();
void updatesnake();
Node * Create_New_Node(int);
void Insert_Beg(Node* );

struct Node
{ int info;
  Node *next;
} *headpos,*newptr,*tailpos,*save,*ptr; //newptr=>for insertion,ptr=>spare

void initiate()
{
headpos=tailpos=NULL;
int inf=(width/2)+(height/2)*width;
newptr=Create_New_Node(inf);
if(newptr==NULL)
{
endgame();
}
Insert_Beg(newptr);

//flag snakes body on MAP
MAP[newptr->info]=1;

//flag top and bottom walls 
for(int i=0; i<20;i++)
{MAP[i]=-1;
 MAP[i+width*(height-1)]=-1;
}

//flag right and left walls
for(int j=0;j<20;++j)
{ MAP[j*width]=-1;
  MAP[(width-1)+j*width]=-1;
}

generatefood();
}

void generatefood(){

time_t t;
int x=0;
int y=0;

do
{
 srand( (unsigned) time(&t) );
x=rand()%(width-2)+1;
y=rand()%(height-2)+1;
}while(MAP[x+y*width]!=0);

foodpos=x+y*width;
MAP[foodpos]=-2;

}

void getdirection(char key)
{
int newpos;
switch(key)
{
case 'w' :newpos=headpos->info-width;
	      break;
case 'a' :newpos=headpos->info-1;
	      break;
case 's' :newpos=headpos->info+1;
	      break; 
case 'd' :newpos=headpos->info+width;
	      break;
}

bool possible = true;   //int possible=1;     for  turbo
ptr=headpos;

//not touching it's body
while(ptr!=NULL)
{
if(newpos==ptr->info)
{ possible=false; break; }

ptr=ptr->next;
}

if(possible=false)
	return;
else
updatesnake(newpos);
}//getdirection ends 

void updatesnake(int &newpos){
newptr=Create_New_Node(newpos);
Insert_Beg(newptr);
if(checkscore()==0)
{
//ptr=newptr->next;
ptr=headpos;
while(ptr!=NULL)
{
if(ptr->next==tailpos)
	break;

ptr=ptr->next;
}
tailpos=ptr;
delete ptr->next;

}

}//updatesnake ends

int checkscore()  //if food is eaten
{if(MAP[headpos->info]==-2)
 return 1;
else 
	return 0;
}

void update_map(){
if(checkscore()==1)
{
score+=2;
generatefood();
}

ptr=headpos;

for(int i=0;i<size;++i)
if(MAP[i]>0)
--MAP[i];

while(ptr!=NULL)
{
MAP[ptr->inf]=1;
ptr=ptr->next;
}

}

void display(){
for(int y=0;y<height;++y)
for(int x=0;x<width;++x)
cout<<Get_Map_Value(MAP[x+y*width]);
cout<<'\n';
}

char Get_Map_Value(int value)
{
switch(value)
{
case -2:return '$';
case -1:return '*';
case 0: return ' ';
case 1: return 'O';
}
}

void rungame(){
initiate();
gotoxy(75,15); // cursor blinks outside playground
do{


}while();
}




